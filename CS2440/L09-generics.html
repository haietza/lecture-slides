<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CS2440</title>

		<link rel="stylesheet" href="../reveal-js/dist/reset.css">
		<link rel="stylesheet" href="../reveal-js/dist/reveal.css">
		<link rel="stylesheet" href="../reveal-js/dist/theme/dracula.css">
		<link rel="stylesheet" href="../layouts/common.css">
		<link rel="stylesheet" href="../reveal-js/plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<div class="header left">
					CS2440: Computer Science II
				</div>
				<div class="header right no-title">
					<em>Generics, Wildcards, and Iterators</em>
				</div>

				<section data-state="title-slide">
					<h1 class="r-fit-text">CS2440: Computer Science II</h1>
					<h2 class="r-fit-text">Generics, Wildcards, and Iterators</h2>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Generics</h3>
					<ul>
						<li>In Java, there are <em>eight primitive types</em>:</li>
						<ul>
							<li><code>byte</code> - 8 bit numeric type</li>
							<li><code>short</code> - 16 bit numeric type</li>
							<li><code>int</code> - 32 bit numeric type</li>
							<li><code>long</code> - 64 bit numeric type</li>
							<li><code>float</code> - 32 bit decimal type</li>
							<li><code>double</code> - 64 bit decimal type</li>
							<li><code>char</code> - display type based on Unicode</li>
							<li><code>boolean</code> - 8 bit, true/false</li>
						</ul>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Generics</h3>
					<ul>
						<li>Everything else is <em>an Object type</em>.</li>
						<li>All objects are part of the <em>hierarchy</em> of Java objects and subclasses of <code>java.lang.Object</code></li>
						<li>We have talked about methods of the Object class that are <em>inherited</em> and that we have <em>overridden</em> to make useful to us: <code>equals()</code>, <code>toString()</code>, <code>compareTo()</code>, etc.</li>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Generics</h3>
					<ul>
						<li>The Java standard library provides many useful <em>container classes</em>, such as <code>ArrayList</code>, <code>Vector</code>, and <code>LinkedList</code></li>
						<li>These are examples of generic classes</li>
						<li>When a generic class is declared, you must indicate what type of objects will be stored in the container</li>
					</ul>
					<pre class="java">
						<code data-trim>
							ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
						</code>
					</pre>
				</section>

				<section data-auto-animate>
					<h3>Generics</h3>
					<pre class="java">
						<code data-trim>
							ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();
						</code>
					</pre>
					<ul>
						<li>The value in the angle brackets is called the <strong>type argument</strong>, and for this reason we sometimes refer to a generic class as a <strong>parameterized type</strong></li>
						<li>One restriction, however, is that you can only use Object types as a type argument. So what do we do when we want to build an <code>ArrayList</code> of <code>int</code>s?</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Wrapper Classes</h3>
					<pre class="java">
						<code data-trim>
							ArrayList&lt;int&gt; a = new ArrayList&lt;int&gt;(); // ERROR
							ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;(); // perfect!
						</code>
					</pre>
					<ul>
						<li>Java provides <strong>wrapper classes</strong> that serve as thin wrappers around each of the primitive types</li>
						<li>Their names are typically the name of the primitive type, but with a capital first letter, with two exceptions</li>
					</ul>
					<pre class="java">
						<code data-trim>
							ArrayList&lt;Integer&gt; a = new ArrayList&lt;Integer&gt;();
							ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); // also allowed
						</code>
					</pre>
				</section>

				<section data-auto-animate>
					<h3>Wrapper Classes</h3>
					<table class="small">
						<thead>
							<tr>
								<td>Primitive type</td>
								<td></td>
								<td>Wrapper class</td>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td><code>byte</code></td>
								<td>&Rightarrow;</td>
								<td><code>Byte</code></td>
							</tr>
							<tr>
								<td><code>short</code></td>
								<td>&Rightarrow;</td>
								<td><code>Short</code></td>
							</tr>
							<tr>
								<td><code>int</code></td>
								<td>&Rightarrow;</td>
								<td><code>Integer</code></td>
							</tr>
							<tr>
								<td><code>long</code></td>
								<td>&Rightarrow;</td>
								<td><code>Long</code></td>
							</tr>
							<tr>
								<td><code>float</code></td>
								<td>&Rightarrow;</td>
								<td><code>Float</code></td>
							</tr>
							<tr>
								<td><code>double</code></td>
								<td>&Rightarrow;</td>
								<td><code>Double</code></td>
							</tr>
							<tr>
								<td><code>char</code></td>
								<td>&Rightarrow;</td>
								<td><code>Character</code></td>
							</tr>
							<tr>
								<td><code>boolean</code></td>
								<td>&Rightarrow;</td>
								<td><code>Boolean</code></td>
							</tr>
						</tbody>
					</table>
				</section>

				<section data-auto-animate>
					<h3>Wrapper Classes</h3>
					<ul>
						<li>Java's wrapper classes support features known as <em>autoboxing</em> and <em>auto-unboxing</em></li>
						<li>You can use wrapper classes in places where the primitive type would have worked, and vice versa</li>
					</ul>
					<pre class="java">
						<code data-trim>
							public static void main(String[] args)
							{
								Integer x = new Integer(5); // normal constructor
								Integer y = 7;              // autoboxing
								Integer z = x + y;          // auto-unboxing to do arithmetic
								System.out.println(x + " + " + y + " = " + z);
							}
						</code>
					</pre>
				</section>

				<section data-auto-animate>
					<h3>Wrapper Classes</h3>
					<ul>
						<li>While these are what we sometimes call <em>thin wrappers</em>, keep in mind they do take up more space than the primitives do alone, so consider that tradeoff</li>
					</ul>
				</section>
				
				<section data-auto-animate data-auto-animate-restart>
					<p><strong>ðŸ’¡Try It:</strong> <em>Write a method that takes an int array as input and reverses it using $o(n)$ auxilliary storage</em></p>
					<pre class="java fragment">
						<code data-trim>
							public static void reverse(int[] data) {
								for (int i = 0; i < data.length / 2; i++) {
									int temp = data[i];
									data[i] = data[data.length - i - 1];
									data[data.length - i - 1] = temp;
								}
							}
						</code>
					</pre>
					<p class="fragment">What if we want to reverse other types of arrays?</p>
				</section>
				
				<section data-auto-animate>
					<h3>Generic Methods</h3>
					<ul>
						<li>One solution to the previous problem is that we could create a <em>unique function</em> for arrays of each type we need to be able to reverse</li>
						<li class="fragment">...or we could make a <strong>generic method</strong>!</li>
					</ul>
				</section>
				
				<section data-auto-animate>
					<h3>Generic Methods</h3>
					<pre class="java">
						<code data-trim>
							// this is a generic method with type parameter T
							public static &lt;T&gt; void reverse(T[] data)
							{
								for (int i = 0; i < data.length / 2; i++)
								{
									T temp = data[i];
									data[i] = data[data.length - i - 1];
									data[data.length - i - 1] = temp;
								}
							}
						</code>
					</pre>
				</section>
				
				<section data-auto-animate>
					<h3>Generic Methods</h3>
					<pre class="java">
						<code data-trim>
							// this is a generic method with type parameter T
							public static &lt;T&gt; void reverse(T[] data)
							{
								for (int i = 0; i < data.length / 2; i++)
								{
									T temp = data[i];
									data[i] = data[data.length - i - 1];
									data[data.length - i - 1] = temp;
								}
							}
						</code>
					</pre>
					<p>A <strong>generic method</strong> is defined by placing the <em>type parameter</em> in angle brackets before the return type</p>
				</section>
				
				<section data-auto-animate data-auto-animate-restart>
					<h3>Type Parameters</h3>
					<ul>
						<li>Since <em>type parameters</em> represent <em>class types</em>, they are conventionally written with capital letters</li>
						<li>The most common type parameters you will see are <code>T</code> and <code>E</code>, but others are occassionally used</li>
						<li><code>N</code> is sometimes used for numeric types, <code>K</code>/<code>V</code> for key-value pairs, and others</li>
					</ul>
				</section>
				
				<section data-auto-animate>
					<h3>Type Parameters</h3>
					<ul>
						<li class="small">There are limitations to what you can do with <em>type parameters</em></li>
						<li class="small fragment">You cannot instantiate an object of the generic type</li>
						<pre class="java fragment">
							<code data-trim>
								T object = new T(); // ERROR
							</code>
						</pre>
						<li class="small fragment">You cannot create an array of the generic type</li>
						<pre class="java fragment">
							<code data-trim>
								T[] array = new T[1000]; // ERROR
							</code>
						</pre>
						<li class="small fragment">These limitations are due to <strong>erasure</strong>, which is a compilation technique in which the exact data type of a generic type is unknown at runtime</li>
					</ul>
				</section>
				
				<section data-auto-animate>
					<h3>Type Parameters</h3>
					<ul>
						<li class="small">If we couldn't create an array of a generic type, it would be a problem for creating <em>container types</em>. There are a few <em>workarounds</em>:</li>
						<ol>
							<li class="small fragment">The array can be of type <code>Object</code>, and we can <em>cast individual values</em></li>
							<pre class="java fragment">
								<code data-trim>
									// we can store type T in this because polymorphism
									Object[] data = new Object[1000];
									
									// cast to type T to fix any issues with type incompatability
									return (T) data[currentIndex];
								</code>
							</pre>
							<li class="small fragment">The <em>whole array</em> can be casted to type <code>T</code></em></li>
							<pre class="java fragment">
								<code data-trim>
									// we can cast the whole array
									T[] data = (T[]) new Object[1000];
								</code>
							</pre>
						</ol>
					</ul>
				</section>
				
				<section data-auto-animate data-auto-animate-restart>
					<h3>Generic Methods</h3>
					<ul>
						<li>Why make a method generic when <code>Object</code> works?</li>
						<pre class="java">
							<code data-trim>
								public static &lt;T&gt; T process(T val)
								// versus
								public static Object process(Object val)
							</code>
						</pre>
					</ul>
				</section>
				
				<section data-auto-animate>
					<h3>Generic Methods</h3>
					<ul>
						<li>Why make a method generic when <code>Object</code> works?</li>
						<ol>
							<li class="small fragment">No casting is required when interacting with containers</li>
							<pre class="java fragment">
								<code data-trim>
									String s = (String) process("a"); // returned Object
									String s = process("a");          // returned String
								</code>
							</pre>
							<li class="small fragment">Type safety at compile time</li>
							<pre class="java fragment">
								<code data-trim>
									public static void add(Object elem) // for a String container
									add(new Rectangle()); // compiles, might error at runtime

									public static &lt;T&gt; void add(T elem) // same container
									add(new Rectangle()); // ERROR, caught at compile time
								</code>
							</pre>
						</ol>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Generic Classes</h3>
					<ul>
						<li>Classes can be generic too</li>
						<li>The <em>type parameter</em> is written directly <em>following the class name</em> in the <em>class header</em></li>
						<pre class="java">
							<code data-trim>
								public class LinkedSeq&lt;E&gt; implements Cloneable
							</code>
						</pre>
						<li>In this example, the type parameter <code>E</code> can now be used as a type throughout the entire class</li>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Generic Classes</h3>
					<p><strong>ðŸ’¡Try It:</strong> <em>Make the following class generic</em></p>
					<pre class="java">
						<code data-trim>
							public class IntBox
							{
								private int data;

								public void set(int data) { this.data = data; }
								public int get() { return this.data; }
							}
						</code>
					</pre>
				</section>

				<section data-auto-animate>
					<h3>Generic Classes</h3>
					<p><strong>ðŸ’¡Try It:</strong> <em>Make the following class generic</em></p>
					<pre class="java">
						<code data-trim>
							public class Box&lt;T&gt;
							{
								private T data;

								public void set(T data) { this.data = data; }
								public T get() { return this.data; }
							}
						</code>
					</pre>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Bounded Type Parameters</h3>
					<ul>
						<li class="small"><em>Generic type parameters</em> don't provide any information to the compiler at compile time, and therefore, the only methods that can be called on a generic type are <code>Object</code> methods</li>
						<li class="small">Perhaps counterintuitively, if you want to be able to call more methods, you need to <em>bound the type parameter</em></li>
						<pre class="java">
							<code data-trim>
								public static &lt;T extends Comparable&lt;T&gt;&gt; 
									int countGreaterThan(T[] array, T elem) 
								{
									int count = 0;
									for (T e : array)
										if (e.compareTo(elem) &gt; 0) ++count;
									return count;
								}								
							</code>
						</pre>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Subclasses of Generic Classes</h3>
					<ul>
						<li class="small">You can create a subclass of a generic class or interface by extending or implementing it</li>
						<pre class="java">
							<code data-trim>
								public class ArrayList&lt;T&gt; extends List&lt;T&gt;
								public class List&lt;T&gt; extends Collection&lt;T&gt;
							</code>
						</pre>
						<li class="small">Additional type parameters can be used</li>
						<pre class="java">
							<code data-trim>
								public class LabeledBox&lt;S,T&gt; extends Box&lt;T&gt;
							</code>
						</pre>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Generic Classes</h3>
					<ul>
						<li>If we wanted to build a <code>LinkedSeq</code> similar to the <code>DoubleLinkedSeq</code> from lab, we wouldn't be able to use <code>DoubleNode</code>. Instead we need a generic <code>Node</code> class</li>
						<pre class="java">
							<code data-trim>
								public class Node&lt;E&gt;
								{
									private E data;
									private Node&lt;E&gt; link;
									// ...
								}
							</code>
						</pre>
					</ul>
				</section>
			</div>
		</div>

		<script src="../reveal-js/dist/reveal.js"></script>
		<script src="../reveal-js/plugin/math/math.js"></script>
		<script src="../reveal-js/plugin/notes/notes.js"></script>
		<script src="../reveal-js/plugin/markdown/markdown.js"></script>
		<script src="../reveal-js/plugin/highlight/highlight.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				slideNumber: true,
				transition: 'convex',
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ],
			});
		</script>
	</body>
</html>
