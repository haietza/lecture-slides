<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CS3460</title>

		<link rel="stylesheet" href="../reveal-js/dist/reset.css">
		<link rel="stylesheet" href="../reveal-js/dist/reveal.css">
		<link rel="stylesheet" href="../reveal-js/dist/theme/dracula.css">
		<link rel="stylesheet" href="../layouts/common.css">
		<link rel="stylesheet" href="../reveal-js/plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<div class="header left">
					CS3460: Data Structures
				</div>
				<div class="header right no-title">
					<em>Graphs & Connectivity</em>
				</div>

				<section data-state="title-slide">
					<h1 class="r-fit-text">CS3460: Data Structures & Algorithms</h1>
					<h2 class="r-fit-text">Graphs & Connectivity</h2>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Graphs (Networks)</h3>
					<ul class="small">
						<li>A <strong>graph</strong> is a collection of <em>nodes</em> (aka, vertices) and <em>edges</em>. Each edge joins a pair of vertices. Nodes and edges can have weights/costs.</li>
						<li class="fragment">Graphs can be <em>directed</em> or <em>undirected</em>, referring to whether or not the edges have a direction. By default, "graph" usually means "undirected graph."</li>
						<li class="fragment">Graphs are very common data structures because they are extremely useful at modeling a wide range of problems and applications.</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Graph Examples</h3>
					<img src="figures/graphs/graph-zachary.svg">

					<aside class="notes">
						examples include social networks, road networks, the internet
					</aside>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Graph Topology</h3>
					<p>There are many special types of graphs. The following are examples of <em>special cases</em> we might encounter:</p>
					<div class="columns">
						<div class="one-column">
							<img src="figures/graphs/graph-path.svg" width="60%">
							<p class="small"><em>Path</em> ($P_n$)</p>
						</div>
						<div class="one-column">
							<img src="figures/graphs/graph-cycle.svg" width="60%">
							<p class="small"><em>Cycle</em> ($C_n$)</p>
						</div>
					</div>
				</section>

				<section data-auto-animate>
					<h3>Graph Topology</h3>
					<p>There are many special types of graphs. The following are examples of <em>special cases</em> we might encounter:</p>
					<div class="columns">
						<div class="one-column">
							<img src="figures/graphs/graph-complete.svg" width="50%">
							<p class="small"><em>Complete</em> graph ($K_n$)</p>
						</div>
						<div class="one-column">
							<img src="figures/graphs/graph-planar.svg" width="70%">
							<p class="small"><em>Planar</em> graph</p>
						</div>
					</div>
				</section>

				<section data-auto-animate>
					<h3>Graph Topology</h3>
					<p>There are many special types of graphs. The following are examples of <em>special cases</em> we might encounter:</p>
					<img src="figures/graphs/graph-bipartite.svg" width="20%">
					<p class="small"><em>Bipartite</em> graph (a <em>complete</em> bipartite graph is denoted $K_{m,n}$)</p>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Graph Terminology</h3>
					<ul class="small">
						<li>A <strong>walk</strong> is a series of nodes connected by edges.</li>
						<ul>
							<li class="fragment">We can think of a walk as a sequence of edges.</li>
							<li class="fragment">Commonly interested in <em>directed walks in a digraph</em>.</li>
						</ul>
						<li class="fragment">A <strong>path</strong> is a "simple" walk (visits no nodes twice).</li>
						<li class="fragment">A <strong>cycle</strong> is a path that starts and ends at the same node.</li>
						<li class="fragment">A <strong>connected component</strong> is a set of nodes that are joined by paths.</li>
						<li class="fragment">In a digraph, a <strong>strongly connected component</strong> is a set of nodes for which all pairs of nodes $i,j$ in that set have a path leading from $i$ to $j$ and from $j$ to $i$.</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Some Classical Graph Problems</h3>
				</section>

				<section data-auto-animate>
					<h3>Shortest Paths</h3>
					<ul class="small">
						<li><strong>Problem:</strong> Find the shortest path between two nodes in a graph.</li>
						<ul>
							<li class="fragment">We can also find the shortest path between one node and all other nodes [referred to as <em>single-source shortest path</em>].</li>
							<li class="fragment">We can also find the shortest path between all pairs of nodes [referred to as <em>all-pairs shortest path</em>].</li>
						</ul>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Minimum Spanning Trees</h3>
					<ul class="small">
						<li><strong>Problem:</strong> Find a min-cost subset of edges that connects all nodes.</li>
					</ul>
					<img src="figures/graphs/graph-minspantree.svg" data-id="minspantree">
				</section>

				<section data-auto-animate>
					<h3>Minimum Spanning Trees</h3>
					<ul class="small">
						<li><strong>Problem:</strong> Find a min-cost subset of edges that connects all nodes.</li>
					</ul>
					<img src="figures/graphs/graph-minspantree2.svg" data-id="minspantree">
				</section>

				<section data-auto-animate>
					<h3>Matchings</h3>
					<div class="columns">
						<div class="one-column">
							<ul class="small">
								<li><strong>Problem:</strong> Pair up as many nodes as possible, or pair all nodes at minimum total cost.</li>
							</ul>
						</div>
						<div class="one-column">
							<img src="figures/graphs/graph-bipartite.svg" data-id="matching">
						</div>
					</div>
				</section>

				<section data-auto-animate>
					<h3>Matchings</h3>
					<div class="columns">
						<div class="one-column">
							<ul class="small">
								<li><strong>Problem:</strong> Pair up as many nodes as possible, or pair all nodes at minimum total cost.</li>
							</ul>
						</div>
						<div class="one-column">
							<img src="figures/graphs/graph-bipartite-matching.svg" data-id="matching">
						</div>
					</div>
				</section>

				<section data-auto-animate>
					<h3>Flow / Routing</h3>
					<ul class="small">
						<li><strong>Problem:</strong> Route a maximum amount of some commodity through a capacitated network, possibly at minimum total cost.</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Network Analysis / Data Mining</h3>
					<ul class="small">
						<li><strong>Similarity / Connectivity:</strong> How similar are nodes $x$ and $y$ if edges connect directly-related elements?</li>
						<li><strong>Clustering:</strong> Does a graph break naturally into several large "clusters"?</li>
						<li><strong>Centrality:</strong> Find nodes that are well-connected with all other nodes.</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Network Analysis / Data Mining</h3>
					<ul class="small">
						<li><strong>Similarity / Connectivity:</strong> How similar are nodes $x$ and $y$ if edges connect directly-related elements?</li>
						<li><strong>Clustering:</strong> Does a graph break naturally into several large "clusters"?</li>
						<li><strong>Centrality:</strong> Find nodes that are well-connected with all other nodes.</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Graph Representations</h3>
					<p>An <strong>adjacency matrix</strong> (ideal for <em>dense</em> graphs)</p>
					<div class="columns">
						<div class="two-columns">
							<img src="figures/graphs/repr-example-1.svg" width="80%">
						</div>
						<div class="one-column">
							<pre>
								<code data-trim>
									    1 2 3 4
									  +--------
									1 | 0 1 0 0
									2 | 0 0 1 0
									3 | 1 0 0 1
									4 | 0 0 1 0
								</code>
							</pre>
						</div>
					</div>
				</section>

				<section data-auto-animate>
					<h3>Graph Representations</h3>
					<p>An <strong>adjacency list</strong> (ideal for <em>sparse</em> graphs)</p>
					<div class="columns">
						<div class="two-columns">
							<img src="figures/graphs/repr-example-2.svg" width="60%">
						</div>
						<div class="one-column">
							<pre>
								<code data-trim>
									1: 2 3
									2: 1 3 4
									3: 1 2 4 5
									4: 2 3 5
									5: 3 4
								</code>
							</pre>
							<p class="small">Unless otherwise stated, we will assume our graphs are represented using adjacency lists.</p>
						</div>
					</div>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Simple Connectivity Questions</h3>
					<ul class="small">
						<li>Some of the most fundamental graph questions related to <em>connectivity</em>:</li>
						<ul>
							<li class="fragment">Are nodes $i$ and $j$ connected by some path?</li>
							<li class="fragment">If so, determine such a path.</li>
							<li class="fragment">In a digraph, is there a directed path from $i$ to $j$?</li>
							<li class="fragment">Does a (directed) graph have a (directed) cycle?</li>
							<li class="fragment">Partition a graph into its connected components.</li>
							<li class="fragment">Partition a digraph into its strongly connected components.</li>
						</ul>
					</ul>
					<div class="fragment exclamation">We can answer all of these questions in $O(n)$ using <strong>depth-first search</strong>.</div>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Depth-First Search (DFS)</h3>
					<pre>
						<code data-trim>
							dfs_visit(i):
								visited[i] = True
								for each j such that (i,j) is an edge:
									if visited[j] is False:
										predecessor[j] = i
										dfs_visit(j)
						</code>
					</pre>
					<pre>
						<code data-trim>
							full_dfs():
								for each i: predecessor[i] = null, visited[i] = False
								for each i: if visited[i] is False: dfs_visit(i)
						</code>
					</pre>
					<ul class="small">
						<li>Works in directed and undirected graphs.</li>
						<li><em>full_dfs()</em> takes $O(m + n)$ &mdash; spends $O(1)$ on each node and edge</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Depth-First Search (DFS)</h3>
					<ul class="small">
						<li><em>full_dfs()</em> gives us an easy way to partition an undirected graph into its connected components.</li>
						<li class="fragment">The predecessor pointers define what is called a <strong>depth-first search tree</strong>.</li>
						<li class="fragment">To find a path from $i$ to $j$ (if such a path exists):</li>
						<ol>
							<li class="fragment">Initialize predecessor and visited values for all nodes.</li>
							<li class="fragment">Call <em>dfs_visit(i)</em>.</li>
							<li class="fragment">Follow predecessor pointers backwards from $j$ to $i$</li>
						</ol>
						<li class="fragment">How could we use this to find a path between any two nodes with only one call to <em>full_dfs()</em>?</li>
					</ul>
				</section>

				<section data-auto-animate data-auto-animate-restart>
					<h3>Topological Sorting</h3>
					<ul class="small">
						<li>A common type of graph is the <strong>Directed Acyclic Graph</strong> (DAG).</li>
						<ul>
							<li class="fragment">As the name implies, this is a digraph that contains no cycles.</li>
							<li class="fragment">Often used to model systems with precedence constraints.</li>
						</ul>
						<li class="fragment">Topological sorting is the process of ordering the nodes of a DAG so that all edges point in a consistent direction. <span class="fragment">You can think of this as "flattening" the DAG into a sequence that satisfies the precedence constraints.</span></li>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Topological Sorting</h3>
					<ul class="small">
						<li>There are several ways to topologically sort in <em>$O(m + n)$</em> time:</li>
						<ul>
							<li class="fragment">Find a node with <em>no incoming edges</em>. Add it next to the ordering, remove it from our graph, and repeat.</li>
							<li class="fragment">If we ever find that every node has an incoming edge, then our graph <em>must contain a cycle</em> (this gives un an alternate way of performing <em>cycle detection</em>).</li>
						</ul>
						<li class="fragment">Depth-first search gives us another very simple topological sorting algorithm.</li>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Topological Sorting</h3>
					<pre>
						<code data-trim data-line-numbers="3,8">
							dfs_visit(i):
								visited[i] = True
								d[i] = current_time; increment current_time
								for each j such that (i,j) is an edge:
									if visited[j] is False:
										predecessor[j] = i
										dfs_visit(j)
								f[i] = current_time; increment current_time
						</code>
					</pre>
					<ul class="small">
						<li>Associate each node with a <em>discovery time</em> and a <em>finishing time</em>.</li>
						<li class="fragment">To topologically sort a DAG, just perform <em>full_dfs()</em> and then output the nodes in reverse order of finishing times.</li>
						<ul>
							<li class="fragment">Either output each node as soon as it is "finished," or sort the nodes by their finishing times (in linear time with counting sort) after the fact.</li>
						</ul>
					</ul>
				</section>

				<section data-auto-animate>
					<h3>Topological Sorting</h3>
					<ul class="small">
						<li><strong>Claim:</strong>In a DAG with an edge from node $i$ to node $j$, $f(i) > f(j)$.</li>
						<li class="fragment"><strong>Proof:</strong> Consider two cases:</li>
						<ol class="fragment">
							<li><em>full_dfs()</em> visits $i$ first.</li>
							<li><em>full_dfs()</em> visits $j$ first.</li>
						</ol>
						<li class="fragment">In both cases, we have $f(i) > f(j)$ as long as our graph contains no directed cycles (which it doesn't, since it is a DAG!)</li>
					</ul>
				</section>
			</div>
		</div>

		<script src="../reveal-js/dist/reveal.js"></script>
		<script src="../reveal-js/plugin/math/math.js"></script>
		<script src="../reveal-js/plugin/notes/notes.js"></script>
		<script src="../reveal-js/plugin/markdown/markdown.js"></script>
		<script src="../reveal-js/plugin/highlight/highlight.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				slideNumber: true,
				transition: 'convex',
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ],
			});
		</script>
	</body>
</html>
