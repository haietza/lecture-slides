<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CS2435 - Lecture 00 - Welcome</title>

		<link rel="stylesheet" href="../reveal-js/dist/reset.css">
		<link rel="stylesheet" href="../reveal-js/dist/reveal.css">
		<link rel="stylesheet" href="../reveal-js/dist/theme/dracula.css">
		<link rel="stylesheet" href="../layouts/common.css">
		<link rel="stylesheet" href="../layouts/tokyo-night-dark.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<div class="header left">
					CS2435: Intro to Scientific Programming
				</div>
				<div class="header right no-title">
					<em>Introduction & Course Overview</em>
				</div>

				<section data-state="title-slide">
					<h1 class="r-fit-text">CS2435: Intro to Scientific Programming</h1>
					<h2 class="r-fit-text">Introduction & Course Overview</h2>
				</section>

				<section class="left" data-markdown data-auto-animate>
					<textarea data-template>
						### Why Study Scientific Programming?
						All of the easy problems are *solved*! Every field is making use of *data science* to solve their hard problems

						*Science, engineering, finance, arts and humanities, commerce, health and wellness*

						Every problem remaining requires processing *big datasets* computationally
						---
						### Why Study Scientific Programming?
						Problem solving, above all else, is *fun*!
					</textarea>
				</section>

				<section class="left" data-markdown>
					<textarea data-template>
						### Programming &ne; Problem Solving
						- Both are valuable skills, but they are not the same!
						- "*Computer Science is no more about computers than astronomy is about telescopes*," attributed to Dijkstra
						- Just as being *fluent in English* does not make one a great *writer*
					</textarea>
				</section>

				<section class="left" data-markdown>
					<textarea data-template>
						### How to Succeed in CS2435
						- *Attend class* and *participate enthusiastically*
						- *Study* and *reinforce* the material through repetition
							- (Attempt practice problems found in handouts!)
						- *Review* previous material before the next lecture
						- Start working on assignments *early* to finish *early*!
					</textarea>
				</section>

				<section class="left" data-markdown>
					<textarea data-template>
						### Why Python?
						- Python has several features that make it ideal!
							- It is a *general-purpose* language
							- It is an *expressive*, *high-level*, *interpreted* language
							- Extensive *third-party libraries*, easy to install
							- Easy to *read*, *write*, and *understand*
					</textarea>
				</section>

				<section class="left" data-markdown>
					<textarea data-template>
						### Types of Knowledge
						- **Declarative knowledge** involves statements of fact
						- **Imperative knowledge** involves a recipe or process
						---
						### Types of Knowledge
						- **Declarative knowledge** involves statements of fact
							- A *chocolate chip cookie* is a baked biscuit usually made primarily of flour, egg, butter, and sugar
						- **Imperative knowledge** involves a recipe or process
							- Heat oven to 375&deg;F
							- Mix sugars, butter, vanilla and egg in large bowl. Stir in flour, baking soda and salt
							- Drop dough by rounded tablespoonfuls about 2 inches apart onto ungreased cookie sheet
							- Bake 8 to 10 minutes or until light brown
						---
						### Types of Knowledge
						- **Declarative knowledge** involves statements of fact
							- $y = \sqrt{x} \iff y \times y = x$
						- **Imperative knowledge** involves a recipe or process
							- How to compute $\sqrt{x}$
								- Start with a guess $y_0$ for $\sqrt{x}$ (perhaps $y_0 = 1$)
								- If $y_i \times y_i$ is close enough to $x$, stop
								- Update guess $y_{i+1} = \dfrac{y_i + \frac{x}{y_i}}{2}$ and repeat
					</textarea>
				</section>

				<section>
					<aside class="notes">
						Assume x = 16<br>
						Start with a guess for y<sub>i</sub>, let's say 3<br>
						Is y<sub>i</sub> x y<sub>i</sub> close enough to x? 3 x 3 = 9, no it's not<br>
						Calculate y<sub>i+1</sub> => (3 + (16/3)) / 2 = 4.17<br>
						Repeat with y<sub>i+1</sub> until close enough to x
					</aside>
					<table class="bordered">
						<thead>
							<tr>
								<td>$y_i$</td>
								<td>$y_i \times y_i$</td>
								<td>$\frac{x}{y_i}$</td>
								<td>$y_{i+1} = \dfrac{y_i + \frac{x}{y_i}}{2}$</td>
							</tr>
						</thead>
						<tbody>
							<tr class="fragment">
								<td>3</td>
								<td>9</td>
								<td>5.333</td>
								<td>4.17</td>
							</tr>
							<tr class="fragment">
								<td>4.17</td>
								<td>17.36</td>
								<td>3.837</td>
								<td>4.0035</td>
							</tr>
							<tr class="fragment">
								<td>4.0035</td>
								<td>16.0277</td>
								<td>3.997</td>
								<td>4.000002</td>
							</tr>
							<tr class="fragment">
								<td>4.000002</td>
								<td>16.000016</td>
								<td></td>
								<td></td>
							</tr>
						</tbody>
					</table>
				</section>

				<section class="left" data-markdown>
					<textarea data-template>
						### What is a Recipe?
						- A *recipe* is
							- a *repeatable* sequence of *control steps*
							- managing the flow of *input* to produce an *output*
							- having a clearly-defined *stopping point*
						- An *algorithm* is just a recipe to solve a computational problem
						- A *program* is just a realization of an algorithm that can be run by a computer
					</textarea>
				</section>

				<section class="left" data-auto-animate>
					<aside class="notes">
						<p>Sagan's quote plays on the literal meaning of "from scratch." If we truly were to start from absolute nothing, we would need to create everything, including the universe, physics and chemistry to understand how ingredients interact, biology to grow the apples, geology to form the earth the ingredients come from, and so onâ€¦</p>
						<p>Programmers build upon the work of those who came before. We use tools and knowledge developed over decades (or centuries) to create new software. We write code in a high-level language, which is then translated into lower-level code, and eventually into machine instructions that the computer's hardware understands. Each layer depends on the ones below it.</p>
						<p>In essence, the quote emphasizes that even seemingly simple tasks rest upon a foundation of immense complexity. In programming, this translates to understanding that every line of code we write is supported by a vast and intricate system. Programming languages make writing programs more like "simple tasks".</p>
					</aside>
					<h3>Programming</h3>
					<ul>
						<li>How do we capture a "recipe" in a mechanical process?</li>
						<li>Programming languages give us a set of rich primitive operations to construct programs</li>
						<li>"<em>If you wish to make an apple pie from scratch, you must first invent the universe</em>" - Carl Sagan</li>
					</ul>
					<p class="fragment"><strong>ðŸ’¡Try It:</strong> <em>Write a Python expression, using the appropriate mathematical tools, to evaluate this common formula.</em></p>
				</section>

				<section class="left" data-auto-animate>
					<h3>Programming</h3>
					<ul>
						<li>Many languages are interchangeable (see *Alan Turing*), but it is the quality of the primitives that separates them</li>
						<ul>
							<li>powerful, low-level <em>assembly languages</em></li>
							<li>balanced, middle-level languages like <em>C</em></li>
							<li>expressive, high-level languages like <em>Python</em></li>
						</ul>
						<li>Programming languages give us a set of rich primitive operations to construct programs</li>
						<li>"<em>If you wish to make an apple pie from scratch, you must first invent the universe</em>" - Carl Sagan</li>
					</ul>
					<p class="fragment"><strong>ðŸ’¡Try It:</strong> <em>Write a Python expression, using the appropriate mathematical tools, to evaluate this common formula.</em></p>
				</section>

				<section class="left" data-auto-animate>
					<aside class="notes">
						<p>Semantic error: Incorrect use of language constructs (e.g., using * instead of + for a sum).</p>
						<p>Logical error: Flaw in the program's reasoning or algorithm (e.g., incorrect conditional statements, flawed logic flow).</p>
					</aside>
					<h3>Programming</h3>
					<ul>
						<li>When things go wrong</li>
						<ul>
							<li><strong>Syntactic errors</strong>: common and very easy to solve</em></li>
							<li><strong>Semantic errors</strong>: some languages detect these before a program can run, some do not</li>
							<li><strong>Logical errors</strong>: difficult to solve</li>
							<ul>
								<li>Program <em>crashes</em></li>
								<li>Program never <em>terminates</em></li>
								<li>Program gives <em>unexpected answer</em></li>
							</ul>
						</ul>
						<li>Programming languages give us a set of rich primitive operations to construct programs</li>
						<li>"<em>If you wish to make an apple pie from scratch, you must first invent the universe</em>" - Carl Sagan</li>
					</ul>
					<p class="fragment"><strong>ðŸ’¡Try It:</strong> <em>Write a Python expression, using the appropriate mathematical tools, to evaluate this common formula.</em></p>
				</section>

				<section class="left" data-markdown data-auto-animate>
					<textarea data-template>
						### Programming
						- We aren't limited to *primitive operations* (thankfully)
							- Computers have *built-in* primitive operations
							- Programming languages provide more *expressive* abstractions of those primatives
							- *Third-party libraries* expand the pool of available operations even further!
							- Your programs provide further *abstractions*
					</textarea>
				</section>
			</div>
		</div>

		<script src="../reveal-js/dist/reveal.js"></script>
		<script src="../reveal-js/plugin/math/math.js"></script>
		<script src="../reveal-js/plugin/notes/notes.js"></script>
		<script src="../reveal-js/plugin/markdown/markdown.js"></script>
		<script src="../reveal-js/plugin/highlight/highlight.js"></script>
		<script>
			Reveal.initialize({
				hash: true,
				slideNumber: true,
				transition: 'convex',
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ],
			});
			Reveal.configure({
				pdfSeparateFragments: false
			})
		</script>
	</body>
</html>
